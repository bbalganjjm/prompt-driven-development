# 프롬프트 기반 개발방법론(PDD) - 개발 단계

**문서 번호**: MTD-006  
**버전**: 1.0.0  
**작성일**: 2025-05-26  
**작성자**: 방법론 팀  
**상태**: 승인됨

## 목차

1. [단계 개요](#단계-개요)
2. [주요 활동 및 태스크](#주요-활동-및-태스크)
   1. [프롬프트 기반 코드 생성](#1-프롬프트-기반-코드-생성)
   2. [코드 리뷰 및 개선](#2-코드-리뷰-및-개선)
   3. [리팩토링 및 최적화](#3-리팩토링-및-최적화)
   4. [품질 관리](#4-품질-관리)
3. [핵심 산출물](#핵심-산출물)
4. [품질 기준 및 체크리스트](#품질-기준-및-체크리스트)
5. [도구 및 기술](#도구-및-기술)
6. [사례 연구: 금융 서비스 앱의 개발 단계](#사례-연구-금융-서비스-앱의-개발-단계)
7. [문제 해결 가이드](#문제-해결-가이드)

---

## 단계 개요

개발 단계는 설계 단계에서 정의된 아키텍처와 명세를 바탕으로 실제 코드를 작성하고 구현하는 과정입니다. PDD 접근 방식에서는 AI를 활용하여 코드 생성, 코드 리뷰, 리팩토링 등을 효율적으로 수행합니다. 이 단계에서는 프롬프트 엔지니어링을 통해 품질 높은 코드를 신속하게 개발하고, 개발자와 AI의 효과적인 협업 모델을 구축합니다.

### 목적

- 설계 명세에 기반한 기능 구현
- 프롬프트를 활용한 효율적인 코드 생성
- 일관된 코딩 스타일 및 표준 준수
- 코드 품질 및 성능 최적화
- 테스트 가능하고 유지보수가 용이한 코드 작성

### 범위

- 백엔드 및 프론트엔드 코드 개발
- 데이터베이스 스키마 및 쿼리 구현
- 단위 테스트 및 통합 테스트 작성
- 코드 리뷰 및 품질 검증
- CI/CD 파이프라인 구성 및 자동화

## 주요 활동 및 태스크

### 1. 프롬프트 기반 코드 생성

#### 1.1 기능 구현을 위한 프롬프트 설계

요구사항과 설계 명세를 바탕으로 효과적인 코드 생성 프롬프트를 설계합니다.

**프롬프트 템플릿 예시:**
```
다음 요구사항과 설계 명세에 따라 [기능 명]을 구현하는 코드를 작성해 주세요:

요구사항:
[기능 요구사항 설명]

설계 명세:
[아키텍처/클래스 설계 정보]

기술 스택:
- 백엔드: Java 17, Spring Boot 3.x
- 프론트엔드: Vue.js 3
- 데이터베이스: PostgreSQL
- 기타: [관련 기술]

다음 사항을 고려하여 구현해 주세요:
1. Spring Boot의 최신 기능 및 모범 사례 활용
2. RESTful API 설계 원칙 준수
3. 적절한 에러 처리 및 예외 관리
4. 보안 모범 사례 적용
5. 단위 테스트 가능한 구조

코드는 다음 구성 요소를 포함해야 합니다:
- 컨트롤러 클래스
- 서비스 인터페이스 및 구현 클래스
- 데이터 액세스 계층(Repository)
- 필요한 DTO, 엔티티 클래스
- 단위 테스트

가능하면 코드에 주석과 JavaDoc을 포함하여 코드의 이해를 돕고,
코드의 각 부분이 설계 명세와 어떻게 연결되는지 설명해 주세요.
```

#### 1.2 단위별 코드 생성 프롬프트

시스템의 각 구성 요소에 대한 세부적인 코드 생성 프롬프트를 작성합니다.

**컨트롤러 생성 프롬프트 예시:**
```
다음 API 명세에 따라 Spring Boot 컨트롤러 클래스를 생성해 주세요:

API 엔드포인트: [엔드포인트 정보]
HTTP 메서드: [GET/POST/PUT/DELETE]
요청 파라미터/바디: [요청 정보]
응답 형식: [응답 정보]
권한 요구사항: [권한 정보]

다음 요구사항을 준수해 주세요:
1. RESTful API 설계 원칙 준수
2. 적절한 HTTP 상태 코드 사용
3. 요청 유효성 검증 구현
4. 응답 메시지 표준화
5. API 문서화(Swagger/OpenAPI)
6. 예외 처리

컨트롤러 클래스는 서비스 계층에 의존하며, 비즈니스 로직을 포함하지 않아야 합니다.
Spring Boot 3.x와 호환되는 최신 어노테이션과 패턴을 사용해 주세요.
```

**서비스 계층 생성 프롬프트 예시:**
```
다음 비즈니스 요구사항에 따른 서비스 계층 코드를 작성해 주세요:

비즈니스 기능: [기능 설명]
주요 흐름:
1. [단계 1]
2. [단계 2]
3. [단계 3]

관련 엔티티: [엔티티 목록 및 관계]
비즈니스 규칙:
- [규칙 1]
- [규칙 2]

다음 구조로 코드를 작성해 주세요:
1. 서비스 인터페이스 정의
2. 서비스 구현 클래스
3. 필요한 DTO 클래스
4. 예외 클래스(필요한 경우)

다음 사항을 고려해 주세요:
1. 트랜잭션 관리
2. 입력 유효성 검증
3. 비즈니스 규칙 적용
4. 예외 처리
5. 로깅

코드는 Spring Framework의 모범 사례를 따르고, 
의존성 주입 및 관심사 분리 원칙을 준수해야 합니다.
```

**데이터 액세스 계층 생성 프롬프트 예시:**
```
다음 엔티티 및 데이터 액세스 요구사항에 맞는 JPA/Hibernate 기반 Repository를 작성해 주세요:

엔티티 클래스:
[엔티티 클래스 정보]

주요 데이터 액세스 패턴:
- [조회 패턴 1]
- [조회 패턴 2]
- [업데이트 패턴]

특수 요구사항:
- [페이징, 정렬 등 요구사항]
- [특수 쿼리 요구사항]
- [성능 관련 요구사항]

다음 내용을 포함해 주세요:
1. Spring Data JPA Repository 인터페이스
2. 필요한 사용자 정의 쿼리 메서드
3. 복잡한 쿼리를 위한 JPQL 또는 네이티브 쿼리
4. QueryDSL 통합(필요한 경우)

최적의 성능과 유지보수성을 고려한 데이터 액세스 계층을 설계해 주세요.
```

#### 1.3 프론트엔드 코드 생성 프롬프트

사용자 인터페이스 및 클라이언트 측 로직 구현을 위한 프롬프트를 작성합니다.

**Vue 컴포넌트 생성 프롬프트 예시:**
```
다음 UI 요구사항에 따른 Vue.js 3 컴포넌트를 작성해 주세요:

컴포넌트 목적: [목적 설명]
UI/UX 설계: [디자인 설명 또는 링크]
주요 기능:
- [기능 1]
- [기능 2]
- [기능 3]

데이터 요구사항:
- [필요한 데이터 및 API 엔드포인트]
- [데이터 형식]

다음 기술을 활용해 주세요:
- Vue.js 3 Composition API
- TypeScript
- Vue Router(필요한 경우)
- Pinia/Vuex 상태 관리(필요한 경우)
- CSS/SCSS(스타일링)

컴포넌트는 다음 구조를 따라야 합니다:
1. 템플릿 섹션(HTML)
2. 스크립트 섹션(TypeScript)
3. 스타일 섹션(SCSS)

다음 사항을 고려해 주세요:
1. 반응형 디자인
2. 접근성(WCAG 지침)
3. 성능 최적화
4. 재사용성 및 모듈성
```

### 2. 코드 리뷰 및 개선

#### 2.1 코드 품질 검토 프롬프트

AI를 활용하여 코드 품질을 검토하고 개선 사항을 식별합니다.

**코드 리뷰 프롬프트 예시:**
```
다음 코드를 검토하고 품질 개선 사항을 제안해 주세요:

'''java
[코드 블록]
'''

다음 측면에서 코드를 평가해 주세요:
1. 코드 가독성 및 명확성
2. 설계 패턴 및 객체지향 원칙 준수
3. 성능 및 효율성
4. 오류 처리 및 예외 관리
5. 보안 취약점
6. 테스트 용이성
7. 코딩 표준 및 스타일 가이드 준수

각 문제점에 대해 다음을 제공해 주세요:
- 문제 설명
- 심각도(높음/중간/낮음)
- 개선된 코드 예시
- 개선 이유 및 이점

코드의 장점도 함께 언급해 주시고, 
특히 코드 품질이 비즈니스 기능 및 유지보수성에 미치는 영향을 평가해 주세요.
```

#### 2.2 코드 최적화 프롬프트

코드의 성능, 메모리 사용량, 응답 시간 등을 최적화하기 위한 프롬프트를 작성합니다.

**성능 최적화 프롬프트 예시:**
```
다음 코드의 성능을 분석하고 최적화 방안을 제안해 주세요:

'''java
[코드 블록]
'''

다음 성능 측면에서 코드를 분석해 주세요:
1. 시간 복잡도
2. 공간 복잡도
3. 데이터베이스 쿼리 효율성
4. 메모리 사용량
5. I/O 작업 및 네트워크 호출
6. 병목 현상 및 지연 요소

각 성능 이슈에 대해 다음을 제공해 주세요:
- 문제 설명
- 최적화된 코드 또는 접근 방식
- 예상되는 성능 향상
- 트레이드오프(있는 경우)

최적화 제안 시 Spring Boot와 PostgreSQL 환경에 특화된 
성능 향상 기법과 모범 사례를 고려해 주세요.
```

#### 2.3 보안 코드 검토 프롬프트

보안 취약점 및 모범 사례 준수 여부를 검토하기 위한 프롬프트를 작성합니다.

**보안 코드 검토 프롬프트 예시:**
```
다음 코드의 보안 취약점을 식별하고 보안 강화 방안을 제안해 주세요:

'''java
[코드 블록]
'''

다음 보안 측면에서 코드를 검토해 주세요:
1. 입력 유효성 검증
2. 인증 및 인가
3. 민감 정보 처리
4. SQL 인젝션 방어
5. XSS 및 CSRF 방어
6. 세션 관리
7. 오류 처리 및 정보 노출
8. 안전하지 않은 직렬화
9. 의존성 취약점

각 보안 이슈에 대해 다음을 제공해 주세요:
- 취약점 설명 및 잠재적 위험
- OWASP Top 10 또는 CWE 참조
- 수정된 안전한 코드 예시
- 추가 보안 강화 제안

Spring Security 모범 사례와 최신 보안 권장사항을 고려한 개선안을 제시해 주세요.
```

### 3. 리팩토링 및 최적화

#### 3.1 코드 리팩토링 프롬프트

기존 코드의 구조를 개선하고 기술적 부채를 해소하기 위한 프롬프트를 작성합니다.

**리팩토링 프롬프트 예시:**
```
다음 코드를 리팩토링하여 가독성, 유지보수성 및 확장성을 개선해 주세요:

'''java
[코드 블록]
'''

다음 리팩토링 목표에 집중해 주세요:
1. 코드 중복 제거
2. 책임 분리 및 단일 책임 원칙(SRP) 적용
3. 복잡한 메서드 분해
4. 명확한 네이밍 및 주석 개선
5. 디자인 패턴 적용(적절한 경우)
6. 테스트 용이성 개선

리팩토링된 코드는 다음 원칙을 준수해야 합니다:
- 기존 기능을 유지(동일한 결과 제공)
- SOLID 원칙 준수
- 코드 응집도 향상 및 결합도 감소
- 자바 및 스프링 모범 사례 따르기

리팩토링 전/후 비교와 각 변경 사항에 대한 설명,
그리고 리팩토링으로 얻을 수 있는 구체적인 이점을 포함해 주세요.
```

#### 3.2 코드 현대화 프롬프트

레거시 코드를 최신 기술 스택과 패턴으로 업그레이드하기 위한 프롬프트를 작성합니다.

**코드 현대화 프롬프트 예시:**
```
다음 레거시 코드를 Java 17 및 Spring Boot 3.x의 최신 기능을 활용하여 현대화해 주세요:

'''java
[레거시 코드 블록]
'''

다음 현대화 측면에 집중해 주세요:
1. Java 8+ 기능 활용(Stream API, Lambda, Optional 등)
2. Java 17 신기능 적용(Record, Sealed 클래스, 패턴 매칭 등)
3. Spring Boot 3.x 기능 활용
4. 명령형 코드에서 함수형 접근 방식으로 전환
5. 레거시 API에서 최신 대안으로 마이그레이션
6. 구식 패턴 대체

현대화된 코드는 다음을 만족해야 합니다:
- 기능적 동일성 유지
- 코드량 감소 및 표현력 증가
- 타입 안전성 향상
- null 처리 개선
- 유지보수성 및 테스트 용이성 향상

코드 변환 전/후 비교 및 각 현대화 기법이 가져오는 
구체적인 이점에 대한 설명을 포함해 주세요.
```

#### 3.3 성능 병목 해결 프롬프트

성능 병목 현상을 식별하고 해결하기 위한 프롬프트를 작성합니다.

**성능 병목 해결 프롬프트 예시:**
```
다음 성능 프로파일링 결과에 기반하여 코드의 성능 병목을 식별하고 해결해 주세요:

성능 이슈:
[성능 이슈 설명 및 프로파일링 결과]

코드:
'''java
[코드 블록]
'''

다음 측면에서 병목 현상을 분석하고 해결해 주세요:
1. 알고리즘 복잡도 및 데이터 구조 최적화
2. 데이터베이스 쿼리 및 인덱싱
3. 캐싱 전략
4. 비동기 및 병렬 처리
5. 리소스 관리(메모리, 연결 등)
6. N+1 쿼리 문제
7. 불필요한 계산 또는 I/O

각 해결책에 대해 다음을 제공해 주세요:
- 병목 원인 분석
- 최적화된 코드
- 성능 개선 추정치
- 모니터링 및 검증 방법

Spring Boot 및 PostgreSQL 환경에서의 성능 최적화 기법과
JVM 튜닝 관련 조언도 포함해 주세요.
```

### 4. 품질 관리

#### 4.1 단위 테스트 생성 프롬프트

코드의 정확성과 신뢰성을 검증하기 위한 단위 테스트를 생성하는 프롬프트를 작성합니다.

**단위 테스트 생성 프롬프트 예시:**
```
다음 코드에 대한 단위 테스트를 작성해 주세요:

'''java
[테스트 대상 코드 블록]
'''

다음 요구사항에 따라 테스트를 작성해 주세요:
1. JUnit 5 및 Mockito 프레임워크 사용
2. 테스트 케이스는 다음 시나리오를 포함해야 함:
   - 정상 케이스(Happy path)
   - 경계값 케이스
   - 예외 케이스
   - 에지 케이스
3. 높은 테스트 커버리지 달성
4. 각 테스트 메서드는 명확한 목적과 설명 포함
5. Given-When-Then 또는 Arrange-Act-Assert 패턴 사용

테스트 클래스는 다음 구조를 따라야 합니다:
- 필요한 의존성 설정 및 목 객체 생성
- 테스트 대상 객체 초기화
- 테스트 메서드(각 시나리오별)
- 필요한 헬퍼 메서드

각 테스트가 검증하는 기능이나 코드 경로를 명확히 설명하고,
테스트 실패 시 디버깅을 용이하게 하는 의미 있는 어설션 메시지를 포함해 주세요.
```

#### 4.2 통합 테스트 생성 프롬프트

컴포넌트 간 상호작용을 검증하기 위한 통합 테스트를 생성하는 프롬프트를 작성합니다.

**통합 테스트 생성 프롬프트 예시:**
```
다음 컴포넌트/서비스에 대한 통합 테스트를 작성해 주세요:

컴포넌트 설명:
[컴포넌트/서비스 설명]

주요 통합 지점:
- [컴포넌트 A와 B의 통합]
- [외부 API 통합]
- [데이터베이스 통합]

다음 요구사항에 따라 통합 테스트를 작성해 주세요:
1. Spring Boot Test 프레임워크 활용
2. 테스트 컨테이너 또는 임베디드 데이터베이스 사용
3. 다음 시나리오 테스트:
   - 엔드투엔드 기능 흐름
   - 경계 조건 및 오류 처리
   - 트랜잭션 관리
   - 비동기 작업
4. 테스트 데이터 설정 및 정리 전략

테스트 클래스는 다음을 포함해야 합니다:
- 필요한 설정 및 환경 구성
- 테스트 데이터 준비
- 통합 시나리오 테스트 메서드
- 검증 로직
- 리소스 정리

통합 테스트가 실제 운영 환경과 유사한 조건에서 실행되도록 
테스트 환경 구성 방법도 설명해 주세요.
```

#### 4.3 코드 품질 매트릭스 분석 프롬프트

코드 품질 메트릭을 분석하고 개선 방안을 제시하는 프롬프트를 작성합니다.

**코드 품질 분석 프롬프트 예시:**
```
다음 코드 품질 메트릭 결과를 분석하고 개선 계획을 제안해 주세요:

코드 품질 메트릭:
- 순환 복잡도: [값]
- 코드 중복률: [값]
- 테스트 커버리지: [값]
- 코드 결합도: [값]
- 코드 응집도: [값]
- 기술적 부채 지수: [값]

문제 코드 샘플:
'''java
[코드 샘플]
'''

다음 관점에서 분석을 제공해 주세요:
1. 각 메트릭의 의미와 현재 값의 해석
2. 업계 표준 또는 권장 값과의 비교
3. 주요 문제 영역 식별
4. 우선순위가 높은 개선 사항

다음을 포함한 개선 계획을 제안해 주세요:
1. 단기(즉시 적용 가능) 개선 사항
2. 중기(다음 스프린트) 개선 사항
3. 장기(기술적 부채 해소) 계획
4. 목표 메트릭 값

각 개선 제안에 대해 구체적인 접근 방식과 
SonarQube, PMD, SpotBugs 등 코드 품질 도구를 활용한 
지속적인 모니터링 방안도 제시해 주세요.
```

## 핵심 산출물

### 1. 소스 코드

프로젝트의 핵심 산출물로, 요구사항과 설계 명세에 따라 구현된 기능을 포함합니다.

**주요 내용:**
- 백엔드 코드(Java/Spring Boot)
- 프론트엔드 코드(Vue.js)
- 데이터베이스 스크립트
- 구성 파일
- 유틸리티 및 공통 코드

### 2. 테스트 코드

소스 코드의 정확성과 품질을 검증하기 위한 자동화된 테스트 코드입니다.

**주요 내용:**
- 단위 테스트
- 통합 테스트
- 기능 테스트
- 성능 테스트
- 테스트 데이터 및 환경 설정

### 3. 문서화된 코드

코드의 이해와 유지보수를 돕기 위한 문서화된 소스 코드입니다.

**주요 내용:**
- JavaDoc/JSDoc 주석
- README 파일
- 코드 사용 예제
- 알고리즘 및 데이터 구조 설명
- 아키텍처 결정 및 설계 패턴 문서화

### 4. 코드 품질 보고서

코드의 품질 상태를 객관적으로 측정하고 문서화한 보고서입니다.

**주요 내용:**
- 정적 코드 분석 결과
- 코드 복잡도 메트릭
- 테스트 커버리지 보고서
- 코드 리뷰 결과 및 개선 사항
- 기술적 부채 관리 계획

### 5. 빌드 및 배포 설정

코드의 빌드, 테스트, 배포를 자동화하기 위한 설정 및 스크립트입니다.

**주요 내용:**
- CI/CD 파이프라인 구성
- 빌드 스크립트(Maven/Gradle)
- 컨테이너화 설정(Dockerfile)
- 환경별 구성 파일
- 배포 자동화 스크립트

## 품질 기준 및 체크리스트

### 코드 품질 체크리스트

#### 1. 가독성 및 유지보수성
- [ ] 일관된 코딩 스타일과 네이밍 규칙 준수
- [ ] 적절한 주석과 문서화
- [ ] 복잡한 로직에 대한 명확한 설명
- [ ] 코드 중복 최소화
- [ ] 메서드 및 클래스 크기 적절성

#### 2. 설계 및 아키텍처
- [ ] 설계 명세 및 아키텍처 원칙 준수
- [ ] SOLID 원칙 적용
- [ ] 적절한 디자인 패턴 사용
- [ ] 관심사 분리 및 모듈화
- [ ] 의존성 주입 및 인터페이스 기반 설계

#### 3. 성능 및 효율성
- [ ] 효율적인 알고리즘 및 데이터 구조 사용
- [ ] 데이터베이스 쿼리 최적화
- [ ] 리소스 관리(메모리, 연결 등) 효율성
- [ ] 비동기 및 병렬 처리 적절한 활용
- [ ] 캐싱 전략 적용

#### 4. 오류 처리 및 견고성
- [ ] 예외 처리 전략 일관성
- [ ] 경계 조건 및 잘못된 입력 처리
- [ ] 적절한 로깅 및 모니터링
- [ ] 실패 안전(Fail-safe) 메커니즘
- [ ] 우아한 성능 저하(Graceful degradation)

#### 5. 보안
- [ ] 입력 유효성 검증
- [ ] 인증 및 인가 메커니즘
- [ ] 민감 정보 보호
- [ ] SQL 인젝션, XSS, CSRF 방어
- [ ] 안전한 세션 관리

#### 6. 테스트 커버리지
- [ ] 핵심 비즈니스 로직 테스트 커버리지
- [ ] 경계 조건 및 예외 케이스 테스트
- [ ] 통합 지점 테스트
- [ ] 성능 및 부하 테스트
- [ ] 테스트 가능한 설계 적용

### 프롬프트 품질 체크리스트

#### 1. 명확성 및 구체성
- [ ] 요구사항과 기대 결과 명확히 정의
- [ ] 필요한 맥락과 제약 조건 포함
- [ ] 기술 스택 및 환경 명시
- [ ] 원하는 코드 구조 및 패턴 설명

#### 2. 완전성
- [ ] 모든 필요한 정보 포함
- [ ] 참조 자료 또는 예시 제공
- [ ] 예외 상황 및 에지 케이스 고려
- [ ] 비기능적 요구사항(성능, 보안 등) 명시

#### 3. 컨텍스트 이해도
- [ ] 프로젝트 특성 반영
- [ ] 도메인 지식 통합
- [ ] 기존 코드베이스와의 일관성 유지
- [ ] 팀 코딩 표준 및 관행 고려

#### 4. 적응성
- [ ] 다양한 구현 접근 방식 허용
- [ ] 명확한 제약 조건과 유연한 부분 구분
- [ ] 반복적 개선을 위한 피드백 메커니즘
- [ ] 다양한 복잡성 수준 처리 가능

## 도구 및 기술

### 1. 코드 생성 및 개발 도구
- **GitHub Copilot**: 인텔리전트 코드 자동 완성
- **JetBrains IDE(IntelliJ IDEA)**: Java/Spring 개발 환경
- **Visual Studio Code**: Vue.js 개발 환경
- **Spring Initializr**: Spring Boot 프로젝트 생성 및 구성
- **Vue CLI**: Vue.js 프로젝트 구성 및 관리

### 2. 테스트 도구
- **JUnit 5**: 자바 단위 테스트 프레임워크
- **Mockito**: 목 객체 프레임워크
- **Testcontainers**: 통합 테스트용 컨테이너
- **Selenium/Cypress**: UI 자동화 테스트
- **JMeter/Gatling**: 성능 및 부하 테스트

### 3. 코드 품질 도구
- **SonarQube**: 코드 품질 및 보안 취약점 분석
- **PMD/SpotBugs**: 정적 코드 분석
- **Checkstyle**: 코딩 표준 준수 검사
- **JaCoCo**: 코드 커버리지 측정
- **ESLint/Prettier**: JavaScript/Vue.js 코드 품질 및 포맷팅

### 4. 빌드 및 배포 도구
- **Maven/Gradle**: 빌드 자동화
- **Jenkins/GitHub Actions**: CI/CD 파이프라인
- **Docker**: 컨테이너화
- **Kubernetes**: 컨테이너 오케스트레이션
- **Ansible/Terraform**: 인프라 자동화

### 5. 프롬프트 관리 도구
- **프롬프트 라이브러리**: 재사용 가능한 프롬프트 템플릿 관리
- **프롬프트 버전 관리**: 효과적인 프롬프트 추적 및 개선
- **컨텍스트 관리 시스템**: 프로젝트 관련 정보 관리 및 프롬프트 통합

## 사례 연구: 금융 서비스 앱의 개발 단계

### 배경
설계 단계를 완료한 금융 관리 앱의 개발 단계에서 PDD를 적용했습니다. 핵심 요구사항으로는 사용자 계정 관리, 금융 거래 동기화, 지출 분석, 예산 관리, 금융 목표 설정 등이 있었습니다.

### PDD 적용 방법
1. **프롬프트 기반 코어 기능 개발**
   - 금융 거래 데이터 모델 및 저장소 레이어 구현
   - 금융 기관 연동 API 개발
   - 예산 관리 비즈니스 로직 구현
   - 사용자 대시보드 UI 컴포넌트 개발

2. **코드 품질 및 보안 강화**
   - AI 기반 코드 리뷰 및 취약점 분석
   - 금융 데이터 암호화 및 보안 처리 검증
   - PCI DSS 규정 준수 확인
   - 코드 품질 메트릭 분석 및 개선

3. **테스트 자동화**
   - 주요 금융 시나리오에 대한 테스트 케이스 자동 생성
   - 다양한 금융 기관 API 통합 테스트
   - 보안 취약점 테스트
   - 성능 및 부하 테스트 시나리오 개발

4. **최적화 및 확장성 개선**
   - 대용량 거래 데이터 처리 성능 최적화
   - 실시간 데이터 동기화 아키텍처 개선
   - 다중 통화 및 국제 거래 지원 확장

### 결과
- 개발 생산성 40% 향상
- 코드 품질 메트릭 25% 개선
- 테스트 커버리지 85% 달성
- 초기 보안 취약점 90% 감소
- 코드 리뷰 시간 60% 단축

### 주요 교훈
1. 도메인 전문 지식(금융)이 풍부한 프롬프트 설계가 코드 품질에 결정적 영향
2. 테스트 케이스 생성에 AI를 활용하면 테스트 커버리지와 품질 크게 향상
3. 코드 생성과 리뷰의 반복적 피드백 루프가 품질 향상의 핵심
4. 보안 관련 코드는 AI 제안 후 추가 전문가 검토 필수
5. 프롬프트 템플릿의 지속적 개선과 공유가 팀 전체 생산성 향상에 기여

## 문제 해결 가이드

### 문제 1: 생성된 코드의 품질 및 일관성 문제

**증상:**
- 생성된 코드가 팀 코딩 표준을 준수하지 않음
- 코드 스타일과 패턴이 일관되지 않음
- 코드 품질 도구에서 많은 경고 발생

**해결 방법:**
1. **코딩 표준 통합 프롬프트**
   ```
   다음은 우리 팀의 Java/Spring Boot 코딩 표준입니다:
   
   [코딩 표준 요약]
   
   이 표준을 다음 코드에 적용하여 개선해 주세요:
   
   '''java
   [코드 블록]
   '''
   
   특히 다음 측면에 주의해 주세요:
   1. 네이밍 규칙(camelCase, PascalCase 등)
   2. 들여쓰기 및 포맷팅
   3. 주석 및 JavaDoc 스타일
   4. 예외 처리 패턴
   5. 로깅 규칙
   
   개선된 코드와 함께 변경 사항 요약 및 
   코딩 표준을 자동으로 적용하기 위한 도구 설정 방법(Checkstyle, SonarQube 등)도 제안해 주세요.
   ```

2. **코드 표준화 워크플로우 설정**
   ```
   우리 팀의 코드 생성 및 검증 워크플로우를 개선하기 위한 계획을 제안해 주세요:
   
   현재 문제점:
   - 코드 스타일 불일치
   - 품질 표준 미준수
   - 리뷰 프로세스 비효율성
   
   다음 요소를 포함한 워크플로우를 설계해 주세요:
   1. 프롬프트 템플릿 표준화
   2. 코드 생성 전/후 검증 단계
   3. 자동화된 코드 품질 검사 통합
   4. 코드 리뷰 프로세스 최적화
   5. 지속적 개선 메커니즘
   
   각 단계별 구체적인 도구, 설정 및 프로세스를 제안하고,
   이 워크플로우를 CI/CD 파이프라인에 통합하는 방법도 설명해 주세요.
   ```

3. **품질 향상 프롬프트 패턴**
   ```
   다음은 고품질 코드 생성을 위한 개선된 프롬프트 패턴입니다:
   
   ```
   [기능 요구사항 설명]
   
   기술 스택: [기술 스택 정보]
   
   코딩 표준:
   1. [핵심 코딩 표준 요약]
   2. [참조 코드 예시]
   
   품질 요구사항:
   1. [정적 분석 도구 통과 기준]
   2. [테스트 커버리지 요구사항]
   3. [성능 기준]
   
   추가 컨텍스트:
   [관련 코드 또는 아키텍처 정보]
   ```
   
   이 패턴을 다음 기능에 적용한 프롬프트를 작성해 주세요:
   [기능 설명]
   
   또한 이 프롬프트 패턴의 각 섹션이 코드 품질에 어떻게 기여하는지와
   효과적인 사용을 위한 모범 사례도 설명해 주세요.
   ```

### 문제 2: 기존 코드베이스와의 통합 어려움

**증상:**
- 생성된 코드가 기존 아키텍처와 맞지 않음
- 의존성 및 네이밍 충돌
- 연동 시 예상치 못한 부작용 발생

**해결 방법:**
1. **코드베이스 컨텍스트 제공 프롬프트**
   ```
   다음은 우리 프로젝트의 핵심 아키텍처 컴포넌트와 코딩 패턴입니다:
   
   아키텍처 개요:
   [아키텍처 다이어그램 또는 설명]
   
   주요 컴포넌트:
   1. [컴포넌트 A 설명 및 책임]
   2. [컴포넌트 B 설명 및 책임]
   
   핵심 패턴:
   1. [패턴 A 설명 및 사용 사례]
   2. [패턴 B 설명 및 사용 사례]
   
   기존 코드 예시:
   '''java
   [관련 코드 샘플]
   '''
   
   이 컨텍스트를 바탕으로, 다음 요구사항에 맞는 코드를 생성해 주세요:
   [요구사항 설명]
   
   생성된 코드는 기존 아키텍처 패턴과 일관되어야 하며,
   네이밍 규칙, 오류 처리 방식, 의존성 관리 등이 
   기존 코드베이스와 조화롭게 통합되어야 합니다.
   ```

2. **통합 테스트 강화 프롬프트**
   ```
   다음 새로 생성된 코드가 기존 시스템과 올바르게 통합되는지 검증하기 위한
   통합 테스트를 설계해 주세요:
   
   새 코드:
   '''java
   [새로 생성된 코드]
   '''
   
   통합 지점:
   1. [기존 컴포넌트 A와의 상호작용]
   2. [기존 컴포넌트 B와의 상호작용]
   
   잠재적 위험 영역:
   1. [위험 영역 1 설명]
   2. [위험 영역 2 설명]
   
   다음을 포함한 통합 테스트 스위트를 개발해 주세요:
   1. 기본 통합 시나리오
   2. 에지 케이스 및 오류 시나리오
   3. 성능 및 부하 시나리오
   4. 롤백 및 복구 시나리오
   
   테스트는 모의 객체(mock)와 실제 컴포넌트를 적절히 조합하여
   실제 환경과 유사한 조건에서 통합 문제를 조기에 발견할 수 있어야 합니다.
   ```

3. **점진적 리팩토링 프롬프트**
   ```
   다음 기존 코드와 새 요구사항을 고려하여, 점진적 리팩토링 계획을 수립해 주세요:
   
   기존 코드:
   '''java
   [기존 코드 블록]
   '''
   
   새 요구사항:
   [새 요구사항 설명]
   
   다음 원칙에 따른 점진적 리팩토링 접근 방식을 제안해 주세요:
   1. 기존 기능의 작동을 유지하면서 변경
   2. 작은 단위로 나누어 단계적 구현
   3. 각 단계마다 통합 및 회귀 테스트
   4. 기존 아키텍처 패턴과의 일관성 유지
   
   각 리팩토링 단계에 대해 다음을 제공해 주세요:
   - 변경 범위 및 목적
   - 구체적인 코드 변경 사항
   - 테스트 전략
   - 잠재적 위험 및 대응 방안
   
   최종 결과는 기존 코드베이스와 자연스럽게 통합되면서도
   새 요구사항을 효과적으로 구현해야 합니다.
   ```

### 문제 3: 복잡한 비즈니스 로직 구현 어려움

**증상:**
- 생성된 코드가 복잡한 도메인 규칙을 올바르게 구현하지 못함
- 비즈니스 엣지 케이스 처리 미흡
- 도메인 전문 지식 부족으로 인한 오류

**해결 방법:**
1. **도메인 지식 강화 프롬프트**
   ```
   다음은 [도메인 영역]의 핵심 비즈니스 규칙과 개념에 대한 설명입니다:
   
   주요 도메인 개념:
   1. [개념 A 정의 및 중요성]
   2. [개념 B 정의 및 중요성]
   
   비즈니스 규칙:
   1. [규칙 1 설명 및 예외 조건]
   2. [규칙 2 설명 및 예외 조건]
   
   일반적인 에지 케이스:
   1. [에지 케이스 1 설명 및 처리 방법]
   2. [에지 케이스 2 설명 및 처리 방법]
   
   이러한 도메인 지식을 바탕으로 다음 기능을 구현해 주세요:
   [기능 요구사항]
   
   구현 시 특히 다음 측면에 주의해 주세요:
   1. 모든 비즈니스 규칙의 정확한 적용
   2. 에지 케이스 및 예외 상황 철저한 처리
   3. 도메인 용어의 일관된 사용
   4. 비즈니스 규칙 변경에 유연하게 대응할 수 있는 설계
   
   구현 코드와 함께 복잡한 규칙이 어떻게 코드로 변환되었는지에 대한
   설명 및 테스트 시나리오도 제공해 주세요.
   ```

2. **도메인 주도 설계(DDD) 접근 프롬프트**
   ```
   다음 도메인 모델을 도메인 주도 설계(DDD) 원칙에 따라 구현해 주세요:
   
   도메인 설명:
   [도메인 설명]
   
   핵심 도메인 객체:
   1. [엔티티 A - 속성, 행동, 불변식]
   2. [엔티티 B - 속성, 행동, 불변식]
   3. [값 객체 C - 속성, 불변성]
   
   도메인 이벤트:
   1. [이벤트 A - 트리거 조건, 포함 정보]
   2. [이벤트 B - 트리거 조건, 포함 정보]
   
   집계 및 경계:
   [집계 루트 및 경계 정의]
   
   다음 DDD 패턴을 적용한 구현 코드를 제공해 주세요:
   1. 풍부한 도메인 모델
   2. 엔티티와 값 객체 구분
   3. 집계 루트를 통한 일관성 유지
   4. 도메인 이벤트를 통한 상호작용
   5. 리포지토리 패턴
   
   코드는 도메인 전문가와의 대화에서 사용된 용어를 그대로 반영하는
   유비쿼터스 언어(Ubiquitous Language)를 따라야 하며,
   비즈니스 규칙을 명시적으로 캡슐화해야 합니다.
   ```

3. **비즈니스 규칙 테스트 프롬프트**
   ```
   다음 복잡한 비즈니스 로직에 대한 철저한 테스트 스위트를 개발해 주세요:
   
   비즈니스 로직:
   '''java
   [비즈니스 로직 코드]
   '''
   
   핵심 비즈니스 규칙:
   1. [규칙 1 설명]
   2. [규칙 2 설명]
   
   테스트에서 다음 시나리오를 반드시 포함해 주세요:
   1. 기본 흐름(Happy Path) 검증
   2. 각 비즈니스 규칙 개별 검증
   3. 규칙 조합 및 상호작용 검증
   4. 경계값 및 에지 케이스
   5. 예외 조건 및 오류 처리
   
   각 테스트는 다음 형식으로 구성해 주세요:
   - 설명적인 테스트 이름(비즈니스 규칙 관점에서)
   - 테스트 설정 및 컨텍스트
   - 특정 규칙 검증을 위한 동작 실행
   - 명확한 비즈니스 결과 검증
   
   테스트는 개발자뿐만 아니라 도메인 전문가도 이해할 수 있을 만큼
   명확하고 비즈니스 용어로 작성되어야 합니다.
   ```

### 문제 4: 성능 및 확장성 문제

**증상:**
- 생성된 코드가 대용량 데이터나 높은 트래픽에서 성능 저하
- 메모리 누수 또는 리소스 고갈
- 병목 현상 및 응답 시간 증가

**해결 방법:**
1. **성능 최적화 프롬프트**
   ```
   다음 코드의 성능 이슈를 분석하고 최적화해 주세요:
   
   '''java
   [성능 이슈가 있는 코드]
   '''
   
   성능 요구사항:
   - 응답 시간: [목표 응답 시간]
   - 처리량: [목표 처리량]
   - 리소스 사용: [메모리/CPU 제한]
   
   다음 측면에서 성능을 분석하고 개선해 주세요:
   1. 알고리즘 및 데이터 구조 최적화
   2. 데이터베이스 쿼리 효율화
   3. 캐싱 전략 적용
   4. 병렬 처리 및 비동기 작업
   5. 리소스 관리 개선
   
   각 최적화 제안에 대해 다음을 제공해 주세요:
   - 현재 성능 이슈 설명
   - 최적화된 코드
   - 예상되는 성능 향상
   - 측정 및 검증 방법
   
   Java/Spring 환경에서의 성능 최적화 모범 사례와
   JVM 튜닝 관련 조언도 함께 제공해 주세요.
   ```

2. **확장성 설계 프롬프트**
   ```
   다음 서비스를 대규모 트래픽과 데이터를 처리할 수 있도록 확장성 있게 재설계해 주세요:
   
   현재 서비스:
   '''java
   [현재 서비스 코드]
   '''
   
   확장성 요구사항:
   - 동시 사용자: [목표 사용자 수]
   - 데이터 볼륨: [목표 데이터 볼륨]
   - 지리적 분산: [필요한 경우]
   
   다음 확장성 패턴 및 기술을 고려해 주세요:
   1. 수평적 확장(샤딩, 파티셔닝)
   2. 로드 밸런싱 및 서비스 디스커버리
   3. 캐싱 계층 및 CDN
   4. 비동기 메시징 및 이벤트 기반 아키텍처
   5. 마이크로서비스 분해(필요한 경우)
   
   재설계된 아키텍처와 코드는 다음을 제공해야 합니다:
   - 확장성 있는 아키텍처 다이어그램
   - 핵심 컴포넌트 구현 코드
   - 확장성 테스트 및 검증 방법
   - 운영 고려사항 및 모니터링 전략
   
   Kubernetes 환경에서의 구현 방안과 
   클라우드 네이티브 패턴 적용 방법도 포함해 주세요.
   ```

3. **성능 테스트 및 프로파일링 프롬프트**
   ```
   다음 서비스의 성능을 테스트하고 프로파일링하기 위한 계획을 수립해 주세요:
   
   대상 서비스:
   [서비스 설명]
   
   성능 목표:
   [성능 목표 및 KPI]
   
   다음 내용을 포함한 성능 테스트 계획을 작성해 주세요:
   1. 테스트 시나리오 및 사용자 패턴
      - 일반 부하 시나리오
      - 최대 부하 시나리오
      - 스파이크 부하 시나리오
   2. 테스트 환경 및 도구 설정
      - JMeter/Gatling 테스트 스크립트
      - 모니터링 도구 설정(Prometheus, Grafana 등)
      - 프로파일링 도구 설정(YourKit, JProfiler 등)
   3. 측정 지표 및 데이터 수집 방법
      - 응답 시간
      - 처리량
      - 오류율
      - 리소스 사용량
   4. 결과 분석 및 병목 식별 방법
   
   각 테스트 시나리오에 대한 구체적인 테스트 스크립트와
   성능 병목을 식별하기 위한 프로파일링 전략도 포함해 주세요.
   ```
